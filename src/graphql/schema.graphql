# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"""
An Ethereum account with balances
"""
type Account {
    """
    Address of the account
    """
    address: Bytes!
    """
    AccountBalances of the account
    """
    balances(first: Int = 100, orderBy: AccountBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AccountBalance_filter): [AccountBalance!]!
    id: ID!
}

"""
An account balance for a given token
"""
type AccountBalance {
    """
    Account
    """
    account: Account!
    """
    Amount as a decimal value
    """
    amount: BigDecimal!
    id: ID!
    """
    Token
    """
    token: Token!
}

"""
A Basket of Bassets (e.g. for mUSD)
"""
type Basket {
    """
    The Bassets in the Basket
    """
    bassets(first: Int = 100, orderBy: Basset_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Basset_filter): [Basset!]!
    """
    The collateralisation ratio of the Basket
    """
    collateralisationRatio: BigInt!
    """
    Expired Bassets in the Basket
    """
    expiredBassets: [Bytes!]!
    """
    Flag for whether the Basket has failed
    """
    failed: Boolean!
    id: ID!
    """
    Masset the Basket belongs to
    """
    masset: Masset!
}

"""
Basket Asset (e.g. DAI for the mUSD basket)
"""
type Basset {
    """
    Basket the Basset is contained in
    """
    basket: Basket!
    id: ID!
    isTransferFeeCharged: Boolean!
    """
    Maximum weight of the basset in its Basket
    """
    maxWeight: BigInt!
    """
    Basset to Masset ratio for quantity conversion
    """
    ratio: BigInt!
    """
    Status of the Basset, e.g. 'Normal'
    """
    status: String!
    """
    The underlying Token for the Basset
    """
    token: Token!
    """
    The vault balance of the Basset in its Basket
    """
    vaultBalance: BigInt!
}

"""
An mStable asset (e.g. mUSD)
"""
type Masset {
    """
    The Basket of Bassets for this Masset
    """
    basket: Basket!
    """
    The address of the fee pool
    """
    feePool: Bytes!
    id: ID!
    """
    The redemption fee
    """
    redemptionFee: BigInt!
    """
    The underlying Token for this Masset
    """
    token: Token!
    """
    The Tranches containing rewards for this Masset
    """
    tranches(first: Int = 100, orderBy: Tranche_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Tranche_filter): [Tranche!]!
}

type Query {
    account(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Account
    accountBalance(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): AccountBalance
    accountBalances(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: AccountBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: AccountBalance_filter
    ): [AccountBalance!]!
    accounts(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Account_filter
    ): [Account!]!
    basket(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Basket
    baskets(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Basket_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Basket_filter
    ): [Basket!]!
    basset(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Basset
    bassets(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Basset_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Basset_filter
    ): [Basset!]!
    masset(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Masset
    massets(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Masset_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Masset_filter
    ): [Masset!]!
    token(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Token
    tokens(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Token_filter
    ): [Token!]!
    tranche(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Tranche
    trancheReward(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): TrancheReward
    trancheRewards(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: TrancheReward_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TrancheReward_filter
    ): [TrancheReward!]!
    tranches(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Tranche_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Tranche_filter
    ): [Tranche!]!
}

type Subscription {
    account(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Account
    accountBalance(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): AccountBalance
    accountBalances(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: AccountBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: AccountBalance_filter
    ): [AccountBalance!]!
    accounts(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Account_filter
    ): [Account!]!
    basket(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Basket
    baskets(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Basket_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Basket_filter
    ): [Basket!]!
    basset(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Basset
    bassets(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Basset_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Basset_filter
    ): [Basset!]!
    masset(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Masset
    massets(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Masset_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Masset_filter
    ): [Masset!]!
    token(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Token
    tokens(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Token_filter
    ): [Token!]!
    tranche(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): Tranche
    trancheReward(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        id: ID!
    ): TrancheReward
    trancheRewards(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: TrancheReward_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: TrancheReward_filter
    ): [TrancheReward!]!
    tranches(
        #The block at which the query should be executed. Can either be an `{ number: Int }` containing the block number or a `{ hash: Bytes }` value containing a block hash. Defaults to the latest block when omitted.
        block: Block_height,
        first: Int = 100,
        orderBy: Tranche_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        where: Tranche_filter
    ): [Tranche!]!
}

"""
An ERC20-compatible token
"""
type Token {
    """
    Token address
    """
    address: Bytes!
    """
    Token decimals
    """
    decimals: Int!
    id: ID!
    """
    Token name
    """
    name: String!
    """
    Token symbol
    """
    symbol: String!
    """
    Quantity of the token that has been burned
    """
    totalBurned: BigDecimal!
    """
    Quantity of the token that has been minted
    """
    totalMinted: BigDecimal!
    """
    Total supply of the token
    """
    totalSupply: BigDecimal!
    """
    Quantity of the token that has been transferred
    """
    totalTransferred: BigDecimal!
}

"""
A Tranche for minting rewards for a given Masset
"""
type Tranche {
    """
    The time at which the claiming period ends
    """
    claimEndTime: BigInt!
    """
    The time at which the Tranche ends
    """
    endTime: BigInt!
    id: ID!
    """
    The Masset the Tranche is for
    """
    masset: Masset!
    """
    Addresses of the rewardees in this Tranche
    """
    rewardees: [Bytes!]!
    """
    The TrancheRewards in this Tranche
    """
    rewards(first: Int = 100, orderBy: TrancheReward_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TrancheReward_filter): [TrancheReward!]!
    """
    The time at which the Tranche starts
    """
    startTime: BigInt!
    """
    The total volume of the Masset minted in this Tranche
    """
    totalMintVolume: BigInt!
    """
    The total reward units (of MTA) for this Tranche
    """
    totalRewardUnits: BigInt!
    """
    The sequential number of this Tranche
    """
    trancheNumber: BigInt!
    """
    The total unclaimed reward units (of MTA) for this Tranche
    """
    unclaimedRewardUnits: BigInt!
    """
    The time at which rewards in this Tranche are unlocked
    """
    unlockTime: BigInt!
}

"""
A reward for minting in a given Tranche
"""
type TrancheReward {
    """
    The quantity of MTA allocated to the rewardee
    """
    allocation: BigInt!
    """
    Flag for whether the reward was claimed
    """
    claimed: Boolean!
    id: ID!
    """
    The volume minted by the rewardee
    """
    mintVolume: BigInt!
    """
    Flag for whether the reward was redeemed
    """
    redeemed: Boolean!
    """
    The address of the rewardee
    """
    rewardee: Bytes!
    """
    The Tranche the reward is for
    """
    tranche: Tranche!
}

enum AccountBalance_orderBy {
    account
    amount
    id
    token
}

enum Account_orderBy {
    address
    balances
    id
}

enum Basket_orderBy {
    bassets
    collateralisationRatio
    expiredBassets
    failed
    id
    masset
}

enum Basset_orderBy {
    basket
    id
    isTransferFeeCharged
    maxWeight
    ratio
    status
    token
    vaultBalance
}

enum Masset_orderBy {
    basket
    feePool
    id
    redemptionFee
    token
    tranches
}

enum OrderDirection {
    asc
    desc
}

enum Token_orderBy {
    address
    decimals
    id
    name
    symbol
    totalBurned
    totalMinted
    totalSupply
    totalTransferred
}

enum TrancheReward_orderBy {
    allocation
    claimed
    id
    mintVolume
    redeemed
    rewardee
    tranche
}

enum Tranche_orderBy {
    claimEndTime
    endTime
    id
    masset
    rewardees
    rewards
    startTime
    totalMintVolume
    totalRewardUnits
    trancheNumber
    unclaimedRewardUnits
    unlockTime
}

input AccountBalance_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    amount: BigDecimal
    amount_gt: BigDecimal
    amount_gte: BigDecimal
    amount_in: [BigDecimal!]
    amount_lt: BigDecimal
    amount_lte: BigDecimal
    amount_not: BigDecimal
    amount_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
}

input Account_filter {
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

input Basket_filter {
    bassets: [String!]
    bassets_contains: [String!]
    bassets_not: [String!]
    bassets_not_contains: [String!]
    collateralisationRatio: BigInt
    collateralisationRatio_gt: BigInt
    collateralisationRatio_gte: BigInt
    collateralisationRatio_in: [BigInt!]
    collateralisationRatio_lt: BigInt
    collateralisationRatio_lte: BigInt
    collateralisationRatio_not: BigInt
    collateralisationRatio_not_in: [BigInt!]
    expiredBassets: [Bytes!]
    expiredBassets_contains: [Bytes!]
    expiredBassets_not: [Bytes!]
    expiredBassets_not_contains: [Bytes!]
    failed: Boolean
    failed_in: [Boolean!]
    failed_not: Boolean
    failed_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

input Basset_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isTransferFeeCharged: Boolean
    isTransferFeeCharged_in: [Boolean!]
    isTransferFeeCharged_not: Boolean
    isTransferFeeCharged_not_in: [Boolean!]
    maxWeight: BigInt
    maxWeight_gt: BigInt
    maxWeight_gte: BigInt
    maxWeight_in: [BigInt!]
    maxWeight_lt: BigInt
    maxWeight_lte: BigInt
    maxWeight_not: BigInt
    maxWeight_not_in: [BigInt!]
    ratio: BigInt
    ratio_gt: BigInt
    ratio_gte: BigInt
    ratio_in: [BigInt!]
    ratio_lt: BigInt
    ratio_lte: BigInt
    ratio_not: BigInt
    ratio_not_in: [BigInt!]
    status: String
    status_contains: String
    status_ends_with: String
    status_gt: String
    status_gte: String
    status_in: [String!]
    status_lt: String
    status_lte: String
    status_not: String
    status_not_contains: String
    status_not_ends_with: String
    status_not_in: [String!]
    status_not_starts_with: String
    status_starts_with: String
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    vaultBalance: BigInt
    vaultBalance_gt: BigInt
    vaultBalance_gte: BigInt
    vaultBalance_in: [BigInt!]
    vaultBalance_lt: BigInt
    vaultBalance_lte: BigInt
    vaultBalance_not: BigInt
    vaultBalance_not_in: [BigInt!]
}

input Block_height {
    hash: Bytes
    number: Int
}

input Masset_filter {
    basket: String
    basket_contains: String
    basket_ends_with: String
    basket_gt: String
    basket_gte: String
    basket_in: [String!]
    basket_lt: String
    basket_lte: String
    basket_not: String
    basket_not_contains: String
    basket_not_ends_with: String
    basket_not_in: [String!]
    basket_not_starts_with: String
    basket_starts_with: String
    feePool: Bytes
    feePool_contains: Bytes
    feePool_in: [Bytes!]
    feePool_not: Bytes
    feePool_not_contains: Bytes
    feePool_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    redemptionFee: BigInt
    redemptionFee_gt: BigInt
    redemptionFee_gte: BigInt
    redemptionFee_in: [BigInt!]
    redemptionFee_lt: BigInt
    redemptionFee_lte: BigInt
    redemptionFee_not: BigInt
    redemptionFee_not_in: [BigInt!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    tranches: [String!]
    tranches_contains: [String!]
    tranches_not: [String!]
    tranches_not_contains: [String!]
}

input Token_filter {
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    symbol: String
    symbol_contains: String
    symbol_ends_with: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_ends_with: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_starts_with: String
    totalBurned: BigDecimal
    totalBurned_gt: BigDecimal
    totalBurned_gte: BigDecimal
    totalBurned_in: [BigDecimal!]
    totalBurned_lt: BigDecimal
    totalBurned_lte: BigDecimal
    totalBurned_not: BigDecimal
    totalBurned_not_in: [BigDecimal!]
    totalMinted: BigDecimal
    totalMinted_gt: BigDecimal
    totalMinted_gte: BigDecimal
    totalMinted_in: [BigDecimal!]
    totalMinted_lt: BigDecimal
    totalMinted_lte: BigDecimal
    totalMinted_not: BigDecimal
    totalMinted_not_in: [BigDecimal!]
    totalSupply: BigDecimal
    totalSupply_gt: BigDecimal
    totalSupply_gte: BigDecimal
    totalSupply_in: [BigDecimal!]
    totalSupply_lt: BigDecimal
    totalSupply_lte: BigDecimal
    totalSupply_not: BigDecimal
    totalSupply_not_in: [BigDecimal!]
    totalTransferred: BigDecimal
    totalTransferred_gt: BigDecimal
    totalTransferred_gte: BigDecimal
    totalTransferred_in: [BigDecimal!]
    totalTransferred_lt: BigDecimal
    totalTransferred_lte: BigDecimal
    totalTransferred_not: BigDecimal
    totalTransferred_not_in: [BigDecimal!]
}

input TrancheReward_filter {
    allocation: BigInt
    allocation_gt: BigInt
    allocation_gte: BigInt
    allocation_in: [BigInt!]
    allocation_lt: BigInt
    allocation_lte: BigInt
    allocation_not: BigInt
    allocation_not_in: [BigInt!]
    claimed: Boolean
    claimed_in: [Boolean!]
    claimed_not: Boolean
    claimed_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    mintVolume: BigInt
    mintVolume_gt: BigInt
    mintVolume_gte: BigInt
    mintVolume_in: [BigInt!]
    mintVolume_lt: BigInt
    mintVolume_lte: BigInt
    mintVolume_not: BigInt
    mintVolume_not_in: [BigInt!]
    redeemed: Boolean
    redeemed_in: [Boolean!]
    redeemed_not: Boolean
    redeemed_not_in: [Boolean!]
    rewardee: Bytes
    rewardee_contains: Bytes
    rewardee_in: [Bytes!]
    rewardee_not: Bytes
    rewardee_not_contains: Bytes
    rewardee_not_in: [Bytes!]
}

input Tranche_filter {
    claimEndTime: BigInt
    claimEndTime_gt: BigInt
    claimEndTime_gte: BigInt
    claimEndTime_in: [BigInt!]
    claimEndTime_lt: BigInt
    claimEndTime_lte: BigInt
    claimEndTime_not: BigInt
    claimEndTime_not_in: [BigInt!]
    endTime: BigInt
    endTime_gt: BigInt
    endTime_gte: BigInt
    endTime_in: [BigInt!]
    endTime_lt: BigInt
    endTime_lte: BigInt
    endTime_not: BigInt
    endTime_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    rewardees: [Bytes!]
    rewardees_contains: [Bytes!]
    rewardees_not: [Bytes!]
    rewardees_not_contains: [Bytes!]
    rewards: [String!]
    rewards_contains: [String!]
    rewards_not: [String!]
    rewards_not_contains: [String!]
    startTime: BigInt
    startTime_gt: BigInt
    startTime_gte: BigInt
    startTime_in: [BigInt!]
    startTime_lt: BigInt
    startTime_lte: BigInt
    startTime_not: BigInt
    startTime_not_in: [BigInt!]
    totalMintVolume: BigInt
    totalMintVolume_gt: BigInt
    totalMintVolume_gte: BigInt
    totalMintVolume_in: [BigInt!]
    totalMintVolume_lt: BigInt
    totalMintVolume_lte: BigInt
    totalMintVolume_not: BigInt
    totalMintVolume_not_in: [BigInt!]
    totalRewardUnits: BigInt
    totalRewardUnits_gt: BigInt
    totalRewardUnits_gte: BigInt
    totalRewardUnits_in: [BigInt!]
    totalRewardUnits_lt: BigInt
    totalRewardUnits_lte: BigInt
    totalRewardUnits_not: BigInt
    totalRewardUnits_not_in: [BigInt!]
    trancheNumber: BigInt
    trancheNumber_gt: BigInt
    trancheNumber_gte: BigInt
    trancheNumber_in: [BigInt!]
    trancheNumber_lt: BigInt
    trancheNumber_lte: BigInt
    trancheNumber_not: BigInt
    trancheNumber_not_in: [BigInt!]
    unclaimedRewardUnits: BigInt
    unclaimedRewardUnits_gt: BigInt
    unclaimedRewardUnits_gte: BigInt
    unclaimedRewardUnits_in: [BigInt!]
    unclaimedRewardUnits_lt: BigInt
    unclaimedRewardUnits_lte: BigInt
    unclaimedRewardUnits_not: BigInt
    unclaimedRewardUnits_not_in: [BigInt!]
    unlockTime: BigInt
    unlockTime_gt: BigInt
    unlockTime_gte: BigInt
    unlockTime_in: [BigInt!]
    unlockTime_lt: BigInt
    unlockTime_lte: BigInt
    unlockTime_not: BigInt
    unlockTime_not_in: [BigInt!]
}


scalar BigDecimal

scalar BigInt

scalar Bytes
